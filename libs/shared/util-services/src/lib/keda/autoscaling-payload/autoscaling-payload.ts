import { type AutoscalingPolicyRequest, type AutoscalingPolicyResponse } from 'qovery-typescript-axios'

/**
 * Extended autoscaling fields for KEDA support
 */
export interface KedaAutoscalingFields {
  scalers?: Array<{
    type: string
    config: string
    trigger_authentication?: { name?: string; config_yaml: string }
  }>
  autoscaling_polling_interval?: number
  autoscaling_cooldown_period?: number
  autoscaling_mode?: 'NONE' | 'HPA' | 'KEDA'
}

type AutoscalingPolicyResponseWithFields = AutoscalingPolicyResponse & {
  polling_interval_seconds?: number
  cooldown_period_seconds?: number
  scalers: Array<{
    scaler_type: string
    enabled: boolean
    role: string
    config_json?: Record<string, unknown>
    config_yaml?: string
    trigger_authentication?: {
      name?: string
      config_yaml?: string
    }
  }>
}

type AutoscalingPolicyRequestWithFields = AutoscalingPolicyRequest & {
  polling_interval_seconds?: number
  cooldown_period_seconds?: number
  scalers: Array<{
    scaler_type: string
    enabled: boolean
    role: 'PRIMARY' | 'SAFETY'
    config_json?: Record<string, unknown>
    config_yaml?: string
    trigger_authentication?: {
      // name is optional for inline trigger authentication (will be auto-generated by backend)
      // name is required when referencing an existing trigger authentication
      name?: string | null
      config_yaml?: string
    }
  }>
}

/**
 * Converts AutoscalingPolicyResponse (from API) to AutoscalingPolicyRequest (for API requests)
 */
export function convertAutoscalingResponseToRequest(
  response: AutoscalingPolicyResponse | undefined
): AutoscalingPolicyRequestWithFields | undefined {
  if (!response) return undefined

  const responseWithFields = response as AutoscalingPolicyResponseWithFields

  const scalers = responseWithFields.scalers ?? []

  return {
    mode: response.mode,
    polling_interval_seconds: responseWithFields.polling_interval_seconds,
    cooldown_period_seconds: responseWithFields.cooldown_period_seconds,
    scalers: scalers.map((scaler) => ({
      scaler_type: scaler.scaler_type,
      enabled: scaler.enabled,
      role: scaler.role as 'PRIMARY' | 'SAFETY',
      config_json: scaler.config_json as Record<string, unknown> | undefined,
      config_yaml: scaler.config_yaml ?? undefined,
      trigger_authentication: scaler.trigger_authentication
        ? {
            // Inline trigger authentication will not have a name (auto-generated by backend)
            // Only include name if provided by API (for referencing existing trigger authentication)
            ...(scaler.trigger_authentication.name ? { name: scaler.trigger_authentication.name } : {}),
            config_yaml: scaler.trigger_authentication.config_yaml ?? '',
          }
        : undefined,
    })),
  } as AutoscalingPolicyRequestWithFields
}

/**
 * Processes autoscaling request and returns the appropriate autoscaling policy
 */
function processAutoscalingRequest(
  request: Partial<KedaAutoscalingFields>,
  currentAutoscaling?: AutoscalingPolicyResponse
): AutoscalingPolicyRequestWithFields | undefined {
  const autoscalingMode = request.autoscaling_mode

  // KEDA mode: use scalers
  if (autoscalingMode === 'KEDA' && request.scalers?.length) {
    const validScalers = request.scalers.filter((s) => s.type?.trim() && s.config?.trim())
    if (validScalers.length === 0) return undefined

    return {
      mode: 'KEDA',
      polling_interval_seconds: request.autoscaling_polling_interval ?? 30,
      cooldown_period_seconds: request.autoscaling_cooldown_period ?? 300,
      scalers: validScalers.map((scaler, index) => ({
        scaler_type: scaler.type,
        enabled: true,
        role: index === 0 ? 'PRIMARY' : 'SAFETY',
        config_json: undefined,
        config_yaml: scaler.config,
        trigger_authentication: scaler.trigger_authentication
          ? {
              // Inline trigger authentication must not have a name (will be auto-generated)
              // Only include name if explicitly provided (for referencing existing trigger authentication)
              ...(scaler.trigger_authentication.name ? { name: scaler.trigger_authentication.name } : {}),
              config_yaml: scaler.trigger_authentication.config_yaml,
            }
          : undefined,
      })),
    } as AutoscalingPolicyRequestWithFields
  }

  // HPA or NONE mode: no autoscaling policy
  if (autoscalingMode === 'HPA' || autoscalingMode === 'NONE') {
    return undefined
  }

  // No mode specified: keep existing autoscaling
  return convertAutoscalingResponseToRequest(currentAutoscaling)
}

/**
 * Extracts and processes autoscaling fields from request
 * Returns the autoscaling policy and a cleaned request without autoscaling fields
 */
export function extractAndProcessAutoscaling<T extends Record<string, unknown>>(
  request: T,
  currentAutoscaling?: AutoscalingPolicyResponse
): {
  autoscaling: AutoscalingPolicyRequestWithFields | undefined
  cleanedRequest: Omit<T, keyof KedaAutoscalingFields>
} {
  const { scalers, autoscaling_polling_interval, autoscaling_cooldown_period, autoscaling_mode, ...rest } =
    request as T &
      KedaAutoscalingFields & {
        hpa_metric_type?: unknown
        hpa_cpu_average_utilization_percent?: unknown
        hpa_memory_average_utilization_percent?: unknown
      }

  const {
    hpa_metric_type,
    hpa_cpu_average_utilization_percent,
    hpa_memory_average_utilization_percent,
    ...cleanedRequest
  } = rest as Record<string, unknown>

  void hpa_metric_type
  void hpa_cpu_average_utilization_percent
  void hpa_memory_average_utilization_percent

  return {
    autoscaling: processAutoscalingRequest(
      { scalers, autoscaling_polling_interval, autoscaling_cooldown_period, autoscaling_mode },
      currentAutoscaling
    ),
    cleanedRequest: cleanedRequest as Omit<T, keyof KedaAutoscalingFields>,
  }
}

/**
 * Form data type for scalers with trigger authentication
 */
export type ScalerFormData = {
  type: string
  config: string
  triggerAuthentication?: string
}

/**
 * Builds autoscaling request payload from form data
 * Handles the transformation for NONE, HPA, and KEDA modes
 */
export function buildAutoscalingRequestFromForm(
  formData: Record<string, unknown>,
  baseRequest: { memory: number; cpu: number; gpu: number }
): Record<string, unknown> {
  const autoscalingMode = formData['autoscaling_mode'] || 'NONE'

  switch (autoscalingMode) {
    case 'NONE':
      // Fixed instances: min = max, no autoscaling
      return {
        ...baseRequest,
        min_running_instances: formData['min_running_instances'],
        max_running_instances: formData['min_running_instances'], // Force max = min
        scalers: null,
        autoscaling_polling_interval: null,
        autoscaling_cooldown_period: null,
        autoscaling_mode: 'NONE',
        hpa_metric_type: undefined,
        hpa_cpu_average_utilization_percent: undefined,
        hpa_memory_average_utilization_percent: undefined,
      }

    case 'HPA': {
      // HPA mode: min !== max, HPA autoscaling
      const metricChoice = formData['hpa_metric_type'] === 'CPU_AND_MEMORY' ? 'CPU_AND_MEMORY' : 'CPU'
      const cpuAverageUtilization = Number(formData['hpa_cpu_average_utilization_percent']) || 60

      return {
        ...baseRequest,
        min_running_instances: formData['min_running_instances'],
        max_running_instances: formData['max_running_instances'],
        scalers: null,
        autoscaling_polling_interval: null,
        autoscaling_cooldown_period: null,
        autoscaling_mode: 'HPA',
        hpa_metric_type: metricChoice,
        hpa_cpu_average_utilization_percent: cpuAverageUtilization,
        hpa_memory_average_utilization_percent:
          metricChoice === 'CPU_AND_MEMORY'
            ? Number(formData['hpa_memory_average_utilization_percent']) || 60
            : undefined,
      }
    }

    case 'KEDA': {
      // KEDA mode: include trigger authentication directly in scaler payload
      const scalersWithAuth = ((formData['scalers'] || []) as ScalerFormData[]).map((scaler) => {
        const baseScaler = {
          type: scaler.type,
          config: scaler.config,
        }

        // If scaler has triggerAuthentication YAML, include it inline
        if (scaler.triggerAuthentication && scaler.triggerAuthentication.trim() !== '') {
          return {
            ...baseScaler,
            trigger_authentication: {
              config_yaml: scaler.triggerAuthentication,
            },
          }
        }

        // No trigger authentication needed
        return baseScaler
      })

      return {
        ...baseRequest,
        min_running_instances: formData['min_running_instances'],
        max_running_instances: formData['max_running_instances'],
        scalers: scalersWithAuth,
        autoscaling_polling_interval: formData['autoscaling_polling_interval']
          ? Number(formData['autoscaling_polling_interval'])
          : undefined,
        autoscaling_cooldown_period: formData['autoscaling_cooldown_period']
          ? Number(formData['autoscaling_cooldown_period'])
          : undefined,
        autoscaling_mode: 'KEDA',
        hpa_metric_type: undefined,
        hpa_cpu_average_utilization_percent: undefined,
        hpa_memory_average_utilization_percent: undefined,
      }
    }

    default:
      return baseRequest
  }
}
